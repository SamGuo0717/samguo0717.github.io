[{"title":"About Linux","url":"/2025/07/21/Linux/","content":"Vim 常用命令参考模式切换\n\n\n命令\n功能\n\n\n\ni\n进入插入模式（当前位置）\n\n\nI\n进入插入模式（行首）\n\n\na\n进入插入模式（当前位置后）\n\n\nA\n进入插入模式（行尾）\n\n\no\n新建下一行并进入插入模式\n\n\nO\n新建上一行并进入插入模式\n\n\nEsc\n退出插入模式到普通模式\n\n\n:\n进入命令模式\n\n\nv\n进入可视模式\n\n\nV\n进入行可视模式\n\n\n光标移动\n\n\n命令\n功能\n\n\n\nh\n左移\n\n\nj\n下移\n\n\nk\n上移\n\n\nl\n右移\n\n\nw\n下一个单词开头\n\n\nb\n上一个单词开头\n\n\ne\n单词结尾\n\n\n0\n行首\n\n\n$\n行尾\n\n\ngg\n文件开头\n\n\nG\n文件结尾\n\n\nCtrl+f\n向下翻页\n\n\nCtrl+b\n向上翻页\n\n\n编辑操作\n\n\n命令\n功能\n\n\n\nx\n删除当前字符\n\n\ndd\n删除当前行\n\n\nyy\n复制当前行\n\n\np\n粘贴到下方\n\n\nP\n粘贴到上方\n\n\nu\n撤销\n\n\nCtrl+r\n重做\n\n\ndw\n删除单词\n\n\ncw\n修改单词\n\n\ncc\n修改整行\n\n\n搜索替换\n\n\n命令\n功能\n\n\n\n/text\n向下搜索text\n\n\n?text\n向上搜索text\n\n\nn\n下一个匹配\n\n\nN\n上一个匹配\n\n\n:s/old/new\n替换当前行第一个old为new\n\n\n:s/old/new/g\n替换当前行所有old为new\n\n\n:%s/old/new/g\n替换全文所有old为new\n\n\n文件操作\n\n\n命令\n功能\n\n\n\n:w\n保存\n\n\n:q\n退出\n\n\n:wq\n保存并退出\n\n\n:q!\n强制退出不保存\n\n\n:w filename\n另存为\n\n\n:e filename\n打开文件\n\n\n行号与跳转\n\n\n命令\n功能\n\n\n\n:set nu\n显示行号\n\n\n:set nonu\n隐藏行号\n\n\n:n\n跳转到第n行\n\n\nnG\n跳转到第n行\n\n\n窗口操作\n\n\n命令\n功能\n\n\n\n:sp\n水平分割窗口\n\n\n:vsp\n垂直分割窗口\n\n\nCtrl+w w\n切换窗口\n\n\nCtrl+w q\n关闭当前窗口\n\n\n实用技巧# 以只读模式打开vim -R filename# 打开文件并跳转到指定行vim +n filename# 同时编辑多个文件vim file1 file2:n        # 下一个文件:prev     # 上一个文件\n","categories":["Linux"],"tags":["linux"]},{"title":"代码审计(1)","url":"/2025/07/21/code-review-1/","content":"PHP代码审计 部分摘自PL$parts = explode(&#x27;.&#x27;, $_GET[&#x27;jwt&#x27;]);$algorithms = array(&#x27;HS256&#x27;, &#x27;HS384&#x27;, &#x27;HS512&#x27;);if (3 !== count($parts)) &#123;  throw new \\InvalidArgumentException(&#x27;Invalid or malformed JWT supplied.&#x27;);&#125;$header = json_decode(self::decode($parts[0]), true);if (in_array($header[&#x27;alg&#x27;], $algorithms)) &#123;  ...&#125;\n\n\nPossible Threat Analysis\n\nAlgorithm Confusion攻击者只检查了HS系列算法\nHS算法RS256 to HS256降级攻击\n得同时存在RS256和HS256\n\n\n攻击原理HS256替换RS256以后RS256签名：使用RSA私钥 + SHA256验证：使用RSA公钥 + SHA256HS256签名：使用HMAC + SHA256 + 共享密钥验证：使用HMAC + SHA256 + 相同的共享密钥\n\nA. 获取RSA公钥常见端点:\n\n&#x2F;.well-known&#x2F;jwks.json\n证书文件\nAPI文档\n之前的合法JWT Token分析\n\nB. 构造恶意JWT// 原始合法的RS256 JWT header:&#123;  &quot;alg&quot;: &quot;RS256&quot;,  &quot;typ&quot;: &quot;JWT&quot;&#125;// 攻击者修改为HS256:&#123;  &quot;alg&quot;: &quot;HS256&quot;,   &quot;typ&quot;: &quot;JWT&quot;&#125;// 恶意payload (攻击者可以任意修改):&#123;  &quot;sub&quot;: &quot;admin&quot;,      // 提升为管理员  &quot;role&quot;: &quot;admin&quot;,  &quot;exp&quot;: 9999999999    // 延长过期时间&#125;\n\nC. 使用公钥作为HMAC密钥签名// 攻击者的签名过程:$publicKey = &quot;-----BEGIN PUBLIC KEY-----\\nMIIBI...&quot;; // 获得的RSA公钥$header = base64url_encode(&#x27;&#123;&quot;alg&quot;:&quot;HS256&quot;,&quot;typ&quot;:&quot;JWT&quot;&#125;&#x27;);$payload = base64url_encode(&#x27;&#123;&quot;sub&quot;:&quot;admin&quot;,&quot;role&quot;:&quot;admin&quot;&#125;&#x27;);$signature = hash_hmac(&#x27;sha256&#x27;, $header.&#x27;.&#x27;.$payload, $publicKey, true);$maliciousJWT = $header.&#x27;.&#x27;.$payload.&#x27;.&#x27;.base64url_encode($signature);\n同时服务器端有相关漏洞代码\n// 存在漏洞的验证代码:function verifyJWT($jwt) &#123;    $parts = explode(&#x27;.&#x27;, $jwt);    $header = json_decode(base64url_decode($parts[0]), true);    $payload = json_decode(base64url_decode($parts[1]), true);    $signature = base64url_decode($parts[2]);        // 漏洞: 服务器根据JWT中声明的算法进行验证    if ($header[&#x27;alg&#x27;] === &#x27;RS256&#x27;) &#123;        // 正常情况: 使用公钥验证RS256签名        return openssl_verify($parts[0].&#x27;.&#x27;.$parts[1], $signature, $publicKey, OPENSSL_ALGO_SHA256);    &#125;     elseif ($header[&#x27;alg&#x27;] === &#x27;HS256&#x27;) &#123;        // 漏洞: 如果JWT声明是HS256，服务器用公钥作为HMAC密钥验证        // 这正是攻击者想要的!        $expectedSignature = hash_hmac(&#x27;sha256&#x27;, $parts[0].&#x27;.&#x27;.$parts[1], $publicKey, true);        return hash_equals($signature, $expectedSignature);    &#125;&#125;\nD. 攻击成功条件\n服务器信任JWTheader中的算法生命\n同时支持RS256和HS256suanfa\n使用相同的密钥材料进行验证\n攻击者能够获得RSA公钥\n没有严格区分不同算法的密钥管理\n\ne.g.\n// 1. 原始合法的RS256 JWT:eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJ1c2VyIiwicm9sZSI6InVzZXIifQ.[RS256_signature]// 2. 攻击者构造的HS256 JWT:eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJ1c2VyIiwicm9sZSI6ImFkbWluIn0.[HS256_signature_using_public_key]// 服务器会用公钥验证HS256签名 -&gt; 验证通过!// 攻击者成功获得admin权限\nE. 如何防护// 1. 强制指定算法，不信任JWT headerfunction verifyJWT($jwt, $expectedAlgorithm = &#x27;RS256&#x27;) &#123;    // 忽略JWT中声明的算法，使用预设算法    if ($expectedAlgorithm !== &#x27;RS256&#x27;) &#123;        throw new Exception(&#x27;Only RS256 allowed&#x27;);    &#125;    // 强制使用RS256验证...&#125;// 2. 算法白名单严格验证$allowedAlgorithms = [&#x27;RS256&#x27;]; // 不包含HS256if (!in_array($header[&#x27;alg&#x27;], $allowedAlgorithms, true)) &#123;    throw new Exception(&#x27;Algorithm not allowed&#x27;);&#125;// 3. 分离不同算法的密钥$rsaKeys = [...];    // RS256专用$hmacKeys = [...];   // HS256专用，绝不混用\n\n缺省JSON格式验证输入来源问题","categories":["代码审计"],"tags":["安全"]},{"title":"Hello World","url":"/2025/07/21/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n"},{"title":"应该填的坑","url":"/2025/07/21/to_do_list/","content":"刚面完了meta知道该刷leetcode啦！！！！I.这里留给刷过的leetcode和解题思路展示1.anagram - array &#x2F; hash table &#x2F; string &#x2F; sorting如何从一堆数中找到anagram\nfrom collections import defaultdictdef group_anagrams(strs):    d = defaultdict(list)    for s in strs:        key = &#x27;&#x27;.join(sorted(s))  # 或用频率数组转成 tuple/string        d[key].append(s)    return list(d.values())\n\n\n变体anagram mappings &#x2F; interchange the key and value for the dictkey-value转转\nclass Solution:    def anagramMappings(self, nums1: List[int], nums2: List[int]) -&gt; List[int]:        ## use a dict as a mappint        # Input: nums1 = [12,28,46,32,50], nums2 = [50,12,32,46,28]        # Output: [1,4,3,2,0]        hashmap = defaultdict(int)        ## 0,1,2,3,4 -&gt; 50,12,32,46,28        for index,val in enumerate(nums2):            hashmap[val] = index                # 0,1,2,3,4 -&gt; 12,28,46,32,50        for index,val in enumerate(nums1):            nums1[index] = hashmap[val]                return nums1\n\n\n\n\n\n题号\n名称\n难度\n模式\n技巧\n\n\n\n49\nGroup Anagrams\nMedium\n多字符串列表\nsort &#x2F; hash by frequency\n\n\n438\nFind All Anagrams in a String\nMedium\n字符串滑窗\n滑动窗口 + frequency map\n\n\n2.simplify path - string &#x2F; stack处理path*这里可以拓展成模仿cd处理def cd(cwd,pwd)\n原题\ndef simplify_path(path):\tcomponents = [comp for comp in path.split(&quot;/&quot;) if comp and comp != &quot;.&quot;]\tcd_stack = []\tfor component in components:\t\tif component == &quot;..&quot;:\t\t\t#返回上级目录，但是不能超过根目录\t\t\tif stack:\t\t\t\tstack.pop()\t\telse:\t\t\tstack.append(component)\treturn &#x27;/&#x27; + &#x27;/&#x27;.join(stack)\n从已知目录开始查找\n##多加一步 处理路径def mock_cd(cwd,path):\tif path.startswith(&quot;/&quot;):\t\ttarget_path = path\telse:\t\ttarget_path = cwd + &#x27;/&#x27; + path##剩下相同\n\n\n\n\n\n题号\n题目名称\n难度\n技术点 &#x2F; 考察内容\n\n\n\n71（变体）\nSimplify Path + 当前目录支持\nMedium\n栈：处理 cwd 初始化 + 相对&#x2F;绝对路径入栈与出栈。模拟 cd cwd path，主考栈操作。\n\n\n588\nDesign In-Memory File System\nHard\nTrie &#x2F; 树 + 栈：模拟 ls、mkdir、addContentToFile、readContentFromFile，目录树遍历和路径拆分\n\n\n(进一步延伸)\nShell 命令完整模拟\nHard+\n多功能支持：cd、ls、pwd、符号链、环境变量。可在 588 基础上扩展，涉及更复杂的数据结构。\n\n\n3.Diameter of Binary Tree - Tree &#x2F; Binary Tree &#x2F; DFS算深度\n## [1,2,3,4,5] -&gt; 3## [1,2] -&gt; 1Class TreeNode:\t\tdef __init__(self,val=0,left=None,right=None):\t\tself.val = val\t\tself.left = left\t\tself.right = right\tdef diameterOfBinaryTree(self,root:Optional [TreeNode]) -&gt; int:\t\tres = 0\t\tdef dfs(root):\t\t\tif not root:\t\t\t\treturn 0\t\t\tl = dfs(root.left)\t\t\tr = dfs(root.right)\t\t\tnonlocal res\t\t\tres = max(res, l+r)\t\t\treturn 1 + max(l,r)\t\tdfs(root)\t\t##这里return的res真正的直径，dfs的return只是给上一次用的\t\treturn res\n\n\n\n\n\n题号\n题目名称\n难度\nDFS返回值\n全局记录\n核心计算公式\n解题思路\n\n\n\n543\n二叉树的直径\nEasy\n节点深度\n最大直径\nleft_depth + right_depth\n在计算深度过程中，用左右子树深度之和更新最大直径\n\n\n687\n最长同值路径\nMedium\n同值路径长度\n最长同值路径\nleft_len + right_len\n只有当前节点值与子节点相同时才能延续路径，否则重置为0\n\n\n124\n二叉树中的最大路径和\nHard\n最大路径贡献\n最大路径和\nnode.val + left_gain + right_gain\n每个节点可选择是否包含子树贡献（负数不要），返回单侧最大贡献\n\n\n563\n二叉树的坡度\nEasy\n子树节点和\n总坡度\nabs(left_sum - right_sum)\n计算每个节点的坡度（左右子树和的差的绝对值），累加到全局\n\n\n110\n平衡二叉树\nEasy\n树高度&#x2F;-1\n是否平衡\nabs(left_height - right_height) &gt; 1\n高度差&gt;1时返回-1表示不平衡，否则返回正常高度\n\n\n968\n二叉树摄像头\nHard\n节点状态(0&#x2F;1&#x2F;2)\n摄像头数量\n状态转移逻辑\n0:需要覆盖，1:有摄像头，2:被覆盖，根据子节点状态决定当前状态\n\n\n366\n寻找二叉树的叶子节点\nMedium\n节点高度\n叶子节点分层\nmax(left_height, right_height) + 1\n按照到叶子节点的距离分层，距离相同的为一层\n\n\n508\n出现次数最多的子树和\nMedium\n子树和\n频次统计\nleft_sum + right_sum + node.val\n计算每个子树和并统计频次，返回出现最多次数的子树和\n\n\nII.这里留给需要增加的安全知识点SQL Injection（如何找注入点）（高级payload）（RBAC for DB）\nXSS - 注意能绕过的mXSS(XSS 具体危害)（可以执行什么）\nCSRF SSRF(samesite,SOP,CORS)(file:&#x2F;&#x2F; gopher:&#x2F;&#x2F;)\n其他注入Crypto - reduce security policy through incorrect ciphers and algorithms decision lead to data disclosure and manipulation1.Do not use cryptography if there is no sensitive data to protect\n1.1 No implementation\n\nMissed something intuitive: No encryption, no access control\nMissed something non-intuitive: No MAC, side-channel leakage, no replay prevention\n\n1.2 Understanding1.3 Mistake\n安全设计比如说一个登录页面III.Control Matrix 部分 先从ASVS看吧A_PLACEHODER_HERE","categories":["杂谈"],"tags":["安全","综述","leetcode","碎碎念"]}]